// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.18;

// Interfaces
import {PanopticPool} from "./PanopticPool.sol";
// Inherited implementations
import {ERC20Minimal} from "@tokens/ERC20Minimal.sol";
import {Multicall} from "@multicall/Multicall.sol";
// Libraries
import {Constants} from "@libraries/Constants.sol";
import {Errors} from "@libraries/Errors.sol";
import {InteractionHelper} from "@libraries/InteractionHelper.sol";
import {Math} from "@libraries/Math.sol";
import {PanopticMath} from "@libraries/PanopticMath.sol";
import {SafeTransferLib} from "@libraries/SafeTransferLib.sol";
// Custom types
import {LeftRightUnsigned, LeftRightSigned} from "@types/LeftRight.sol";
import {LiquidityChunk} from "@types/LiquidityChunk.sol";
import {TokenId} from "@types/TokenId.sol";

/// @title Collateral Tracking System / Margin Accounting used in conjunction with a Panoptic Pool.
/// @author Axicon Labs Limited
//
/// @notice Tracks collateral of users which is key to ensure the correct level of collateralization is achieved.
/// This is represented as an ERC20 share token. A Panoptic pool has 2 tokens, each issued by its own instance of a CollateralTracker.
/// All math within this contract pertains to a single token.
//
/// @notice This contract uses the ERC4626 standard allowing the minting and burning of "shares" (represented using ERC20 inheritance) in exchange for underlying "assets".
/// Panoptic uses a collateral tracking system that is similar to TradFi margin accounts. While users can borrow and
/// effectively control funds several times larger than the collateral they deposited, they cannot withdraw those funds
/// from the Panoptic-Uniswap ecosystem. All funds are always owned by the Panoptic protocol, but users will:
//
/// @notice 1) collect any fees generated by selling an option.
//
/// @notice 2) get any gain in capital that results from buying an option that becomes in-the-money.
contract CollateralTracker is ERC20Minimal, Multicall {
    // Used for safecasting
    using Math for uint256;

    /*//////////////////////////////////////////////////////////////
                                EVENTS
    //////////////////////////////////////////////////////////////*/

    /// @notice Emitted when assets are deposited into the Collateral Tracker.
    /// @param sender The address of the caller (and depositor)
    /// @param owner The address of the recipient of the newly minted shares
    /// @param assets The amount of assets deposited by 'sender' in exchange for 'shares'
    /// @param shares The amount of shares minted to 'owner'
    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);

    /// @notice Emitted when assets are withdrawn from the Collateral Tracker.
    /// @param sender The address of the caller
    /// @param receiver The address of the recipient of the withdrawn assets
    /// @param owner The address of the owner of the shares being burned
    /// @param assets The amount of assets withdrawn to 'receiver'
    /// @param shares The amount of shares burned by 'owner' in exchange for 'assets'
    event Withdraw(
        address indexed sender,
        address indexed receiver,
        address indexed owner,
        uint256 assets,
        uint256 shares
    );

    /*//////////////////////////////////////////////////////////////
                               CONSTANTS
    //////////////////////////////////////////////////////////////*/

    /// @notice Prefix for the token symbol (i.e. poUSDC).
    string internal constant TICKER_PREFIX = "po";

    /// @notice Prefix for the token name (i.e POPT-V1 USDC LP on ETH/USDC 30bps).
    string internal constant NAME_PREFIX = "POPT-V1";

    /// @notice Decimals for computation (1 bps (basis point) precision: 0.01%).
    /// @dev uint type for composability with unsigned integer based mathematical operations.
    uint256 internal constant DECIMALS = 10_000;

    /// @notice Decimals for computation (1 bps (basis point) precision: 0.01%).
    /// @dev int type for composability with signed integer based mathematical operations.
    int128 internal constant DECIMALS_128 = 10_000;

    /*//////////////////////////////////////////////////////////////
                           UNISWAP POOL DATA
    //////////////////////////////////////////////////////////////*/

    /// @notice The address of underlying token0 or token1 from the Uniswap Pool.
    /// @dev Whether this is token0 or token1 depends on which collateral token is being tracked in this CollateralTracker instance.
    address internal s_underlyingToken;

    /// @notice Boolean which tracks whether this CollateralTracker has been initialized.
    /// @dev As each instance is deployed via proxy clone, initial parameters must only be initalized once via startToken().
    bool internal s_initialized;

    /// @notice Stores address of token0 from the underlying Uniswap V3 pool.
    address internal s_univ3token0;

    /// @notice Stores address of token1 from the underlying Uniswap V3 pool.
    address internal s_univ3token1;

    /// @notice Store whether the current collateral token is token0 of the AMM (true) or token1 (false).
    bool internal s_underlyingIsToken0;

    /*//////////////////////////////////////////////////////////////
                           PANOPTIC POOL DATA
    //////////////////////////////////////////////////////////////*/

    /// @dev The Collateral Tracker keeps a reference to the Panoptic Pool using it.
    PanopticPool internal s_panopticPool;

    /// @dev Cached amount of assets accounted to be held by the Panoptic Pool — ignores donations, pending fee payouts, and other untracked balance changes.
    uint128 internal s_poolAssets;

    /// @dev Amount of assets moved from the Panoptic Pool to the AMM.
    uint128 internal s_inAMM;

    /// @notice additional risk premium charged on intrinsic value of ITM positions,
    /// defined in basis points as a multiple of the pool fee / 10_000.
    /// @dev The result of the calculation is stored instead of the multiple to save gas during usage.
    /// When the fee is set, the multiple is calculated and stored
    uint128 internal s_ITMSpreadFee;

    /// @dev The fee of the Uniswap pool.
    uint24 internal s_poolFee;

    /*//////////////////////////////////////////////////////////////
                            RISK PARAMETERS
    //////////////////////////////////////////////////////////////*/

    /// @dev Amount of ticks that correspond to a move of -SELLER_COLLATERAL_RATIO/DECIMALS.
    uint256 immutable TICK_DEVIATION;

    /// @notice when creating an option, collect a commission for the Panoptic LPs.
    /// In Panoptic, options never expire, commissions are only paid when a new position is minted.
    /// We believe that this will eliminate the impact of the commission fee on the user's decision-making process when closing a position.
    uint256 immutable COMMISSION_FEE;

    // base collateral ratios
    /// @notice Required collateral ratios for buying, represented as percentage * 10_000.
    /// i.e 20% -> 0.2 * 10_000 = 2_000.
    uint256 immutable SELLER_COLLATERAL_RATIO;

    /// @notice Required collateral ratios for selling, represented as percentage * 10_000.
    /// i.e 10% -> 0.1 * 10_000 = 1_000.
    uint256 immutable BUYER_COLLATERAL_RATIO;

    // liquidation parameters
    /// @notice basal cost to force exercise a position that is barely far-the-money (out-of-range).
    int256 immutable FORCE_EXERCISE_COST;

    // Targets a pool utilization (balance between buying and selling)
    /// @notice Target pool utilization below which buying+selling is optimal, represented as percentage * 10_000.
    /// i.e 50% -> 0.5 * 10_000 = 5_000.
    uint256 immutable TARGET_POOL_UTIL;

    /// @notice Pool utilization above which selling is 100% collateral backed, represented as percentage * 10_000.
    /// i.e 90% -> 0.9 * 10_000 = 9_000.
    uint256 immutable SATURATED_POOL_UTIL;

    /// @notice multiplier, in basis points, to the pool fee that is charged on the intrinsic value of ITM positions.
    /// e.g. ITM_SPREAD_MULTIPLIER = 20_000, s_ITMSpreadFee = 2 * s_poolFee
    uint256 immutable ITM_SPREAD_MULTIPLIER;

    /*//////////////////////////////////////////////////////////////
                            ACCESS CONTROL
    //////////////////////////////////////////////////////////////*/

    /// @notice Ensure that the associated Panoptic pool is the caller. Revert if not.
    modifier onlyPanopticPool() {
        if (msg.sender != address(s_panopticPool)) revert Errors.NotPanopticPool();
        _;
    }

    /*//////////////////////////////////////////////////////////////
                  INITIALIZATION & PARAMETER SETTINGS
    //////////////////////////////////////////////////////////////*/

    constructor(
        uint256 _commissionFee,
        uint256 _sellerCollateralRatio,
        uint256 _buyerCollateralRatio,
        int256 _forceExerciseCost,
        uint256 _targetPoolUtilization,
        uint256 _saturatedPoolUtilization,
        uint256 _ITMSpreadMultiplier
    ) {
        COMMISSION_FEE = _commissionFee;
        SELLER_COLLATERAL_RATIO = _sellerCollateralRatio;
        BUYER_COLLATERAL_RATIO = _buyerCollateralRatio;
        FORCE_EXERCISE_COST = _forceExerciseCost;
        TARGET_POOL_UTIL = _targetPoolUtilization;
        SATURATED_POOL_UTIL = _saturatedPoolUtilization;
        ITM_SPREAD_MULTIPLIER = _ITMSpreadMultiplier;

        // calculate amount of ticks required for upwards and downwards moves, used to check if current and mini-median tick
        // are out of sync (then apply a 100% collateral requirement)
        unchecked {
            // taylor expand log(1-sellCollateralRatio)/log(1.0001) around sellCollateralRatio=2000 up to 3rd order
            /// since we're dropping the higher order terms, which are all negative, this will underestimate the number of ticks for a 20% move
            int256 ratioTick = (int256(_sellerCollateralRatio) - 2000);
            TICK_DEVIATION = uint256(
                2230 +
                    (12500 * ratioTick) /
                    10_000 +
                    (7812 * ratioTick ** 2) /
                    10_000 ** 2 +
                    (6510 * ratioTick ** 3) /
                    10_000 ** 3
            );
        }
    }

    /// @notice Initialize a new collateral tracker for a specific token corresponding to the Panoptic Pool being created by the factory that called it.
    /// @dev The factory calls this function to start a new collateral tracking system for the incoming token at 'underlyingToken'.
    /// The factory will do this for each of the two tokens being tracked. Thus, the collateral tracking system does not track *both* tokens at once.
    /// @param underlyingIsToken0 whether this collateral tracker is for token0 (true) or token1 (false).
    /// @param token0 token 0 of the Uniswap pool.
    /// @param token1 token 1 of the Uniswap pool.
    /// @param fee the fee of the Uniswap pool.
    /// @param panopticPool the address of the Panoptic Pool being created and linked to this Collateral Tracker.
    function startToken(
        bool underlyingIsToken0,
        address token0,
        address token1,
        uint24 fee,
        PanopticPool panopticPool
    ) external {
        // fails if already initialized
        if (s_initialized) revert Errors.CollateralTokenAlreadyInitialized();
        s_initialized = true;

        // these virtual shares function as a multiplier for the capital requirement to manipulate the pool price
        // e.g if the virtual shares are 10**6, then the capital requirement to manipulate the price to 10**12 is 10**18
        totalSupply = 10 ** 6;

        // set total assets to 1
        // the initial share price is defined by 1/virtualShares
        s_poolAssets = 1;

        // store the address of the underlying ERC20 token
        s_underlyingToken = underlyingIsToken0 ? token0 : token1;

        // store the Panoptic pool for this collateral token
        s_panopticPool = panopticPool;

        // cache the pool fee in basis points
        uint24 _poolFee;
        unchecked {
            _poolFee = fee / 100;
        }
        s_poolFee = _poolFee;

        // Stores the addresses of the underlying tracked tokens.
        s_univ3token0 = token0;
        s_univ3token1 = token1;

        // store whether the current collateral token is token0 (true) or token1 (false; since there's always exactly two tokens it could be)
        s_underlyingIsToken0 = underlyingIsToken0;

        // Additional risk premium charged on intrinsic value of ITM positions
        unchecked {
            s_ITMSpreadFee = uint128((ITM_SPREAD_MULTIPLIER * _poolFee) / DECIMALS);
        }
    }

    /*//////////////////////////////////////////////////////////////
                        COLLATERAL TOKEN INFORMATION
    //////////////////////////////////////////////////////////////*/

    /// @notice Get the Panoptic pool data.
    /// @dev the Panoptic pool owns this collateral token. This token, in turn, keeps a reference to the Panoptic pool.
    /// @return poolAssets cached amount of assets accounted to be held by the Panoptic Pool - ignores donations, pending fee payouts, and other untracked balance changes.
    /// @return insideAMM the underlying token amount held in the AMM.
    /// @return currentPoolUtilization Packing of the pool utilization (how much funds are in the Panoptic pool versus the AMM pool at the time of minting),
    /// right 64bits for token0 and left 64bits for token1, defined as (inAMM * 10_000) / totalAssets().
    /// Where totalAssets is the total tracked assets in the AMM and PanopticPool minus fees and donations to the Panoptic pool.
    function getPoolData()
        external
        view
        returns (uint256 poolAssets, uint256 insideAMM, int256 currentPoolUtilization)
    {
        poolAssets = s_poolAssets;
        insideAMM = s_inAMM;
        currentPoolUtilization = _poolUtilization();
    }

    /// @notice Returns name of token composed of underlying token symbol and pool data.
    /// @return name The name of the token.
    function name() external view returns (string memory) {
        // this logic requires multiple external calls and error handling, so we do it in a delegatecall to a library to save bytecode size
        return
            InteractionHelper.computeName(
                s_univ3token0,
                s_univ3token1,
                s_underlyingIsToken0,
                s_poolFee,
                NAME_PREFIX
            );
    }

    /// @notice Returns symbol as prefixed symbol of underlying token.
    /// @return symbol The symbol of the token.
    function symbol() external view returns (string memory) {
        // this logic requires multiple external calls and error handling, so we do it in a delegatecall to a library to save bytecode size
        return InteractionHelper.computeSymbol(s_underlyingToken, TICKER_PREFIX);
    }

    /// @notice Returns decimals of underlying token (0 if not present)
    /// @return decimals The decimals of the token.
    function decimals() external view returns (uint8) {
        // this logic requires multiple external calls and error handling, so we do it in a delegatecall to a library to save bytecode size
        return InteractionHelper.computeDecimals(s_underlyingToken);
    }

    /*//////////////////////////////////////////////////////////////
                     LIMITED TRANSFER FUNCTIONS
    //////////////////////////////////////////////////////////////*/

    /// @dev See {IERC20-transfer}.
    /// Requirements:
    /// - the caller must have a balance of at least 'amount'.
    /// - the msg.sender must not have any position on the panoptic pool
    function transfer(
        address recipient,
        uint256 amount
    ) public override(ERC20Minimal) returns (bool) {
        // make sure the caller does not have any open option positions
        // if they do: we don't want them sending panoptic pool shares to others
        // since that's like reducing collateral

        if (s_panopticPool.numberOfPositions(msg.sender) != 0) revert Errors.PositionCountNotZero();

        return ERC20Minimal.transfer(recipient, amount);
    }

    /// @dev See {IERC20-transferFrom}.
    /// Requirements:
    /// - the 'from' must have a balance of at least 'amount'.
    /// - the caller must have allowance for 'from' of at least 'amount' tokens.
    /// - 'from' must not have any open positions on the panoptic pool.
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) public override(ERC20Minimal) returns (bool) {
        // make sure the caller does not have any open option positions
        // if they do: we don't want them sending panoptic pool shares to others
        // as this would reduce their amount of collateral against the opened positions

        if (s_panopticPool.numberOfPositions(from) != 0) revert Errors.PositionCountNotZero();

        return ERC20Minimal.transferFrom(from, to, amount);
    }

    /*//////////////////////////////////////////////////////////////
                     STANDARD ERC4626 INTERFACE
    //////////////////////////////////////////////////////////////*/

    /// @notice Get the token contract address of the underlying asset being managed.
    /// @return assetTokenAddress The address of the underlying asset.
    function asset() external view returns (address assetTokenAddress) {
        return s_underlyingToken;
    }

    /// @notice Get the total amount of assets managed by the CollateralTracker vault.
    /// @dev This returns the total tracked assets in the AMM and PanopticPool,
    /// @dev - EXCLUDING the amount of collected fees (because they are reserved for short options)
    /// @dev - EXCLUDING any donations that have been made to the pool
    /// @return totalManagedAssets The total amount of assets managed.
    function totalAssets() public view returns (uint256 totalManagedAssets) {
        unchecked {
            return s_poolAssets + s_inAMM;
        }
    }

    /// @notice Returns the amount of shares that can be minted for the given amount of assets.
    /// @param assets The amount of assets to be deposited.
    /// @return shares The amount of shares that can be minted.
    function convertToShares(uint256 assets) public view returns (uint256 shares) {
        return Math.mulDiv(assets, totalSupply, totalAssets());
    }

    /// @notice Returns the amount of assets that can be redeemed for the given amount of shares.
    /// @param shares The amount of shares to be redeemed.
    /// @return assets The amount of assets that can be redeemed.
    function convertToAssets(uint256 shares) public view returns (uint256 assets) {
        return Math.mulDiv(shares, totalAssets(), totalSupply);
    }

    /// @notice returns The maximum deposit amount.
    /// @return maxAssets The maximum amount of assets that can be deposited.
    function maxDeposit(address) external pure returns (uint256 maxAssets) {
        return type(uint104).max;
    }

    /// @notice Returns shares received for depositing given amount of assets.
    /// @param assets The amount of assets to be deposited.
    /// @return shares The amount of shares that can be minted.
    function previewDeposit(uint256 assets) public view returns (uint256 shares) {
        // compute the MEV tax, which is equal to a single payment of the commissionRate on the FINAL (post mev-tax) assets paid
        unchecked {
            shares = Math.mulDiv(
                assets * (DECIMALS - COMMISSION_FEE),
                totalSupply,
                totalAssets() * DECIMALS
            );
        }
    }

    /// @notice Deposit underlying tokens (assets) to the Panoptic pool from the LP and mint corresponding amount of shares.
    /// There is a maximum asset deposit limit of (2 ** 104) - 1.
    /// An MEV tax is levied, which is equal to a single payment of the commissionRate BEFORE adding the funds.
    /// @dev Shares are minted and sent to the LP ('receiver').
    /// @param assets Amount of assets deposited.
    /// @param receiver User to receive the shares.
    /// @return shares The amount of Panoptic pool shares that were minted to the recipient.
    function deposit(uint256 assets, address receiver) external returns (uint256 shares) {
        if (assets > type(uint104).max) revert Errors.DepositTooLarge();

        shares = previewDeposit(assets);

        // transfer assets (underlying token funds) from the user/the LP to the PanopticPool
        // in return for the shares to be minted
        SafeTransferLib.safeTransferFrom(
            s_underlyingToken,
            msg.sender,
            address(s_panopticPool),
            assets
        );

        // mint collateral shares of the Panoptic Pool funds (this ERC20 token)
        _mint(receiver, shares);

        // update tracked asset balance
        unchecked {
            s_poolAssets += uint128(assets);
        }

        emit Deposit(msg.sender, receiver, assets, shares);
    }

    /// @notice Returns the maximum shares received for a deposit.
    /// @return maxShares The maximum amount of shares that can be minted.
    function maxMint(address) external view returns (uint256 maxShares) {
        unchecked {
            return (convertToShares(type(uint104).max) * DECIMALS) / (DECIMALS + COMMISSION_FEE);
        }
    }

    /// @notice Returns the amount of assets that would be deposited to mint a given amount of shares.
    /// @param shares The amount of shares to be minted.
    /// @return assets The amount of assets that would be deposited.
    function previewMint(uint256 shares) public view returns (uint256 assets) {
        // round up depositing assets to avoid protocol loss
        // This prevents minting of shares where the assets provided is rounded down to zero
        // compute the MEV tax, which is equal to a single payment of the commissionRate on the FINAL (post mev-tax) assets paid
        // finalAssets - convertedAssets = commissionRate * finalAssets
        // finalAssets - commissionRate * finalAssets = convertedAssets
        // finalAssets * (1 - commissionRate) = convertedAssets
        // finalAssets = convertedAssets / (1 - commissionRate)
        unchecked {
            assets = Math.mulDivRoundingUp(
                shares * DECIMALS,
                totalAssets(),
                totalSupply * (DECIMALS - COMMISSION_FEE)
            );
        }
    }

    /// @notice Deposit required amount of assets to receive specified amount of shares.
    /// There is a maximum asset deposit limit of (2 ** 104) - 1.
    /// An MEV tax is levied, which is equal to a single payment of the commissionRate BEFORE adding the funds.
    /// @dev Shares are minted and sent to the LP ('receiver').
    /// @param shares Amount of shares to be minted.
    /// @param receiver User to receive the shares.
    /// @return assets The amount of assets deposited to mint the desired amount of shares.
    function mint(uint256 shares, address receiver) external returns (uint256 assets) {
        assets = previewMint(shares);

        if (assets > type(uint104).max) revert Errors.DepositTooLarge();

        // transfer assets (underlying token funds) from the user/the LP to the PanopticPool
        // in return for the shares to be minted
        SafeTransferLib.safeTransferFrom(
            s_underlyingToken,
            msg.sender,
            address(s_panopticPool),
            assets
        );

        // mint collateral shares of the Panoptic Pool funds (this ERC20 token)
        _mint(receiver, shares);

        // update tracked asset balance
        unchecked {
            s_poolAssets += uint128(assets);
        }

        emit Deposit(msg.sender, receiver, assets, shares);
    }

    /// @notice Returns The maximum amount of assets that can be withdrawn for a given user.
    /// If the user has any open positions, the max withdrawable balance is zero.
    /// @dev Calculated from the balance of the user; limited by the assets the pool has available.
    /// @param owner The address being withdrawn for.
    /// @return maxAssets The maximum amount of assets that can be withdrawn.
    function maxWithdraw(address owner) public view returns (uint256 maxAssets) {
        // We can only use the standard 4626 withdraw function if the user has no open positions
        // For the sake of simplicity assets can only be withdrawn through the redeem function
        uint256 available = s_poolAssets;
        uint256 balance = convertToAssets(balanceOf[owner]);
        return s_panopticPool.numberOfPositions(owner) == 0 ? Math.min(available, balance) : 0;
    }

    /// @notice Returns the amount of shares that would be burned to withdraw a given amount of assets.
    /// @param assets The amount of assets to be withdrawn.
    /// @return shares The amount of shares that would be burned.
    function previewWithdraw(uint256 assets) public view returns (uint256 shares) {
        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.

        return Math.mulDivRoundingUp(assets, supply, totalAssets());
    }

    /// @notice Redeem the amount of shares required to withdraw the specified amount of assets.
    /// We can only use this standard 4626 withdraw function if the user has no open positions.
    /// @dev Shares are burned and assets are sent to the LP ('receiver').
    /// @param assets Amount of assets to be withdrawn.
    /// @param receiver User to receive the assets.
    /// @param owner User to burn the shares from.
    /// @return shares The amount of shares burned to withdraw the desired amount of assets.
    function withdraw(
        uint256 assets,
        address receiver,
        address owner
    ) external returns (uint256 shares) {
        if (assets > maxWithdraw(owner)) revert Errors.ExceedsMaximumRedemption();

        shares = previewWithdraw(assets);

        // check/update allowance for approved withdraw
        if (msg.sender != owner) {
            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.

            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;
        }

        // burn collateral shares of the Panoptic Pool funds (this ERC20 token)
        _burn(owner, shares);

        // update tracked asset balance
        unchecked {
            s_poolAssets -= uint128(assets);
        }

        // transfer assets (underlying token funds) from the PanopticPool to the LP
        SafeTransferLib.safeTransferFrom(
            s_underlyingToken,
            address(s_panopticPool),
            receiver,
            assets
        );

        emit Withdraw(msg.sender, receiver, owner, assets, shares);

        return shares;
    }

    /// @notice Returns the maximum amount of shares that can be redeemed for a given user.
    /// If the user has any open positions, the max redeemable balance is zero.
    /// @param owner The redeeming address.
    /// @return maxShares The maximum amount of shares that can be redeemed.
    function maxRedeem(address owner) public view returns (uint256 maxShares) {
        uint256 available = convertToShares(s_poolAssets);
        uint256 balance = balanceOf[owner];
        return s_panopticPool.numberOfPositions(owner) == 0 ? Math.min(available, balance) : 0;
    }

    /// @notice returns the amount of assets resulting from a given amount of shares being redeemed
    /// @param shares the amount of shares to be redeemed
    /// @return assets the amount of assets resulting from the redemption
    function previewRedeem(uint256 shares) public view returns (uint256 assets) {
        return convertToAssets(shares);
    }

    /// @notice Redeem exact shares for underlying assets
    /// We can only use this standard 4626 redeem function if the user has no open positions.
    /// @param shares Amount of shares to be redeemed
    /// @param receiver User to receive the assets
    /// @param owner User to burn the shares from
    /// @return assets the amount of assets resulting from the redemption
    function redeem(
        uint256 shares,
        address receiver,
        address owner
    ) external returns (uint256 assets) {
        if (shares > maxRedeem(owner)) revert Errors.ExceedsMaximumRedemption();

        // check/update allowance for approved redeem
        if (msg.sender != owner) {
            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.

            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;
        }

        assets = previewRedeem(shares);

        // burn collateral shares of the Panoptic Pool funds (this ERC20 token)
        _burn(owner, shares);

        // update tracked asset balance
        unchecked {
            s_poolAssets -= uint128(assets);
        }

        // transfer assets (underlying token funds) from the PanopticPool to the LP
        SafeTransferLib.safeTransferFrom(
            s_underlyingToken,
            address(s_panopticPool),
            receiver,
            assets
        );

        emit Withdraw(msg.sender, receiver, owner, assets, shares);

        return assets;
    }

    /*//////////////////////////////////////////////////////////////
                        ACCOUNTING LOGIC
    //////////////////////////////////////////////////////////////*/

    /// @notice Get the cost of exercising an option. Used during a forced exercise.
    /// @dev This one computes the cost of calling the forceExercise function on a position:
    /// - The forceExercisor will have to *pay* the exercisee because their position will be closed "against their will"
    /// - The cost must be larger when the position is close to being in-range, and should be minimal when it is far from being in range. eg. Exercising a (1000, 1050)
    ///   position will cost more if the price is 999 than if it is 100
    /// - The cost is an exponentially decaying function of the distance between the position's strike and the current price
    /// - The cost decreases by a factor of 2 for every "position's width"
    /// - Note that the cost is the largest among all active legs, not the sum
    /// @dev Example exercise costs:
    /// - 10% if the position is liquidated when the price is between 950 and 1000, or if it is between 1050 and 1100
    /// - 5% if the price is between 900 and 950 or (1100, 1150)
    /// - 2.5% if between (850, 900) or (1150, 1200)
    /// @param currentTick The current price tick.
    /// @param oracleTick The price oracle tick.
    /// @param positionId The position to be exercised
    /// @param positionBalance The balance in `account` of the position to be exercised
    /// @param longAmounts The amount of longs in the position.
    /// @return exerciseFees The fees for exercising the option position.
    function exerciseCost(
        int24 currentTick,
        int24 oracleTick,
        TokenId positionId,
        uint128 positionBalance,
        LeftRightSigned longAmounts
    ) external view returns (LeftRightSigned exerciseFees) {
        // find the leg furthest to the strike price 'currentTick'; this will have the lowest exercise cost
        // we don't need the leg information itself, really just "the number of half ranges" from the strike price:
        uint256 maxNumRangesFromStrike = 1; // technically "maxNum(Half)RangesFromStrike" but the name is long

        unchecked {
            for (uint256 leg = 0; leg < positionId.countLegs(); ++leg) {
                // short legs are not counted - exercise is intended to be based on long legs
                if (positionId.isLong(leg) == 0) continue;

                {
                    int24 range = int24(
                        int256(
                            Math.unsafeDivRoundingUp(
                                uint24(positionId.width(leg) * positionId.tickSpacing()),
                                2
                            )
                        )
                    );
                    maxNumRangesFromStrike = Math.max(
                        maxNumRangesFromStrike,
                        uint256(Math.abs(currentTick - positionId.strike(leg)) / range)
                    );
                }

                uint256 currentValue0;
                uint256 currentValue1;
                uint256 oracleValue0;
                uint256 oracleValue1;

                {
                    LiquidityChunk liquidityChunk = PanopticMath.getLiquidityChunk(
                        positionId,
                        leg,
                        positionBalance
                    );

                    (currentValue0, currentValue1) = Math.getAmountsForLiquidity(
                        currentTick,
                        liquidityChunk
                    );

                    (oracleValue0, oracleValue1) = Math.getAmountsForLiquidity(
                        oracleTick,
                        liquidityChunk
                    );
                }

                uint256 tokenType = positionId.tokenType(leg);
                // compensate user for loss in value if chunk has lost money between current and median tick
                // note: the delta for one token will be positive and the other will be negative. This cancels out any moves in their positions
                if (
                    (tokenType == 0 && currentValue1 < oracleValue1) ||
                    (tokenType == 1 && currentValue0 < oracleValue0)
                )
                    exerciseFees = exerciseFees.sub(
                        LeftRightSigned
                            .wrap(0)
                            .toRightSlot(
                                int128(uint128(oracleValue0)) - int128(uint128(currentValue0))
                            )
                            .toLeftSlot(
                                int128(uint128(oracleValue1)) - int128(uint128(currentValue1))
                            )
                    );
            }

            // note: we HAVE to start with a negative number as the base exercise cost because when shifting a negative number right by n bits,
            // the result is rounded DOWN and NOT toward zero
            // this divergence is observed when n (the number of half ranges) is > 10 (ensuring the floor is not zero, but -1 = 1bps at that point)
            // subtract 1 from max half ranges from strike so fee starts at FORCE_EXERCISE_COST when moving OTM
            int256 fee = (FORCE_EXERCISE_COST >> (maxNumRangesFromStrike - 1)); // exponential decay of fee based on number of half ranges away from the price

            // store the exercise fees in the exerciseFees variable
            exerciseFees = exerciseFees
                .toRightSlot(int128((longAmounts.rightSlot() * fee) / DECIMALS_128))
                .toLeftSlot(int128((longAmounts.leftSlot() * fee) / DECIMALS_128));
        }
    }

    /// @notice Get the pool utilization; it is a measure of the ratio of assets in the AMM vs the total assets managed by the pool.
    // With total assets being the current Panoptic pool balance + the amount in the AMM.
    /// @dev compute: inAMM/totalAssets().
    /// @dev 1bps precision controlled by DECIMALS.
    /// @return poolUtilization the pool utilization as a fraction.
    function _poolUtilization() internal view returns (int256 poolUtilization) {
        unchecked {
            return int256((s_inAMM * DECIMALS) / totalAssets());
        }
    }

    /// @notice Get the (sell) collateral ratio that is paid when a short option is minted at a specific pool utilization.
    /// @dev This is computed at the time the position is minted.
    /// @param utilization The fraction of totalAssets() that belongs to the Uniswap Pool.
    /// @return sellCollateralRatio The sell collateral ratio.
    function _sellCollateralRatio(
        int256 utilization
    ) internal view returns (uint256 sellCollateralRatio) {
        // the sell ratio is on a straight line defined between two points (x0,y0) and (x1,y1):
        //   (x0,y0) = (targetPoolUtilization,min_sell_ratio) and
        //   (x1,y1) = (saturatedPoolUtilization,max_sell_ratio)
        // the line's formula: y = a * (x - x0) + y0, where a = (y1 - y0) / (x1 - x0)
        /**
            SELL
            COLLATERAL
            RATIO
                          ^
                          |                  max ratio = 100%
                   100% - |                _------
                          |             _-¯
                          |          _-¯
                    20% - |---------¯
                          |         .       . .
                          +---------+-------+-+--->   POOL_
                                   50%    90% 100%     UTILIZATION
        */

        uint256 min_sell_ratio = SELLER_COLLATERAL_RATIO;
        /// if utilization is less than zero, this is the calculation for a strangle, which gets 2x the capital efficiency at low pool utilization
        /// at 0% utilization, strangle legs do not compound efficiency
        if (utilization < 0) {
            unchecked {
                min_sell_ratio /= 2;
                utilization = -utilization;
            }
        }

        // return the basal sell ratio if pool utilization is lower than target
        if (uint256(utilization) < TARGET_POOL_UTIL) {
            return min_sell_ratio;
        }

        // return 100% collateral ratio if utilization is above saturated pool utilization
        // this means all new positions are fully collateralized, which reduces risks of insolvency at high pool utilization
        if (uint256(utilization) > SATURATED_POOL_UTIL) {
            return DECIMALS;
        }

        unchecked {
            return
                min_sell_ratio +
                ((DECIMALS - min_sell_ratio) * (uint256(utilization) - TARGET_POOL_UTIL)) /
                (SATURATED_POOL_UTIL - TARGET_POOL_UTIL);
        }
    }

    /// @notice Get the (buy) collateral ratio that is paid when a long option is minted at a specific pool utilization.
    /// @dev This is computed at the time the position is minted.
    /// @param utilization The fraction of totalBalance() that belongs to the Uniswap Pool.
    /// @return buyCollateralRatio The buy collateral ratio.
    function _buyCollateralRatio(
        uint256 utilization
    ) internal view returns (uint256 buyCollateralRatio) {
        // linear from BUY to BUY/2 between 50% and 90%
        // the buy ratio is on a straight line defined between two points (x0,y0) and (x1,y1):
        //   (x0,y0) = (targetPoolUtilization,buyCollateralRatio) and
        //   (x1,y1) = (saturatedPoolUtilization,buyCollateralRatio / 2)
        // note that y1<y0 so the slope is negative:
        // aka the buy ratio starts high and drops to a lower value with increased utilization; the sell ratio does the opposite (slope is positive)
        // the line's formula: y = a * (x - x0) + y0, where a = (y1 - y0) / (x1 - x0)
        // but since a<0, we rewrite as:
        // y = a' * (x0 - x) + y0, where a' = (y0 - y1) / (x1 - x0)

        // HOWEVER, if the utilization is larger than 10_000, then default to 100% buying power requirement.
        // this denotes a situation where the median is too far away from the current price, so we need to require fully collateralized positions for safety
        /**
          BUY
          COLLATERAL
          RATIO
                 ^
                 |   buy_ratio = 10%
           10% - |----------__       min_ratio = 5%
           5%  - | . . . . .  ¯¯¯--______
                 |         .       . .
                 +---------+-------+-+--->   POOL_
                          50%    90% 100%      UTILIZATION
         */

        // return the basal buy ratio if pool utilization is lower than target
        if (utilization < TARGET_POOL_UTIL) {
            return BUYER_COLLATERAL_RATIO;
        }

        // return the basal ratio divided by 2 if pool utilization is above saturated pool utilization
        /// this is incentivized buying, which returns funds to the panoptic pool
        if (utilization > SATURATED_POOL_UTIL) {
            unchecked {
                return BUYER_COLLATERAL_RATIO / 2;
            }
        }

        unchecked {
            return
                (BUYER_COLLATERAL_RATIO +
                    (BUYER_COLLATERAL_RATIO * (SATURATED_POOL_UTIL - utilization)) /
                    (SATURATED_POOL_UTIL - TARGET_POOL_UTIL)) / 2; // do the division by 2 at the end after all addition and multiplication; b/c y1 = buyCollateralRatio / 2
        }
    }

    /*////////////////////////////////////////////////////////////////////
          LIFECYCLE OF A COLLATERAL TOKEN AND DELEGATE/REVOKE LOGIC
    ////////////////////////////////////////////////////////////////////*/

    /// @notice Delegate and transfer shares corresponding to the incoming assets 'from' delegator 'to' delegatee.
    /// @dev This is controlled by the Panoptic Pool - not individual users.
    /// @param delegator The delegator to send shares from - the sender of the shares.
    /// @param delegatee The delegatee to send shares to - the recipient of the shares.
    /// @param assets The assets to which the shares delegated correspond.
    function delegate(
        address delegator,
        address delegatee,
        uint256 assets
    ) external onlyPanopticPool {
        /*
                ┌────────┐
                │Panoptic│
                │Pool    │
                └────┬───┘
                     │(1) convert 'assets' to shares (this ERC20 contract)
        ┌─────────┐  │  ┌─────────┐
        │delegator├──▼──►delegatee│
        └─────────┘(2)  └─────────┘
                move shares
                from delegator
                to delegatee
        */

        uint256 shares = convertToShares(assets);

        // transfer shares from the delegator to the delegatee
        _transferFrom(delegator, delegatee, shares);
    }

    /// @notice Delegate and transfer shares corresponding to the incoming assets from the protocol to `delegatee`.
    /// @dev This is controlled by the Panoptic Pool - not individual users.
    /// @dev mints ghost shares so a position can be settled - the total supply is not affected.
    /// @param delegatee The delegatee to send shares to - the recipient of the shares.
    /// @param assets The assets to which the shares delegated correspond.
    function delegate(address delegatee, uint256 assets) external onlyPanopticPool {
        balanceOf[delegatee] += convertToShares(assets);
    }

    /// @notice Refunds delegated tokens back to the protocol
    /// @dev Assumes that `delegatee` has enough money to pay for the refund
    /// @dev burns ghost shares after a position has been settled - the total supply is not affected.
    /// @param delegatee The account refunding tokens to 'delegatee'.
    /// @param assets The amount of assets to which the shares to refund to the protocol correspond.
    function refund(address delegatee, uint256 assets) external onlyPanopticPool {
        balanceOf[delegatee] -= convertToShares(assets);
    }

    /// @notice Revoke previously delegated shares. The opposite of 'delegate'.
    /// @param delegator The delegator to send shares *to* (because we are revoking - opposite when we delegate).
    /// @param delegatee The delegatee to send shares *from* (because we are revoking - opposite when we delegate).
    /// @param assets The assets to which the shares revoked correspond.
    function revoke(
        address delegator,
        address delegatee,
        uint256 assets
    ) external onlyPanopticPool {
        /**
                ┌────────┐
                │Panoptic│
                │Pool    │
                └────┬───┘
                     │(1) convert 'assets' to shares (this ERC20 contract)
        ┌─────────┐  │ ┌─────────┐
        │delegator◄──▼─┤delegatee│
        └─────────┘(2) └─────────┘
            moves shares
            from delegatee
            back to delegator
        */

        uint256 shares = convertToShares(assets);

        // get the delegateeBalance and compare later against requestedAmount
        uint256 delegateeBalance = balanceOf[delegatee];

        // if requested amount is larger than user balance, transfer shares back,
        // then issue new shares
        if (shares > delegateeBalance) {
            // transfer delegatee balance to delegator
            _transferFrom(delegatee, delegator, delegateeBalance);

            // this is paying out protocol loss, so correct for that in the amount of shares to be minted
            // X: total assets in vault
            // Y: total supply of shares
            // Z: desired value (assets) of shares to be minted
            // N: total shares corresponding to Z
            // T: transferred shares from liquidatee which are a component of N but do not contribute toward protocol loss
            // Z = N * X / (Y + N - T)
            // Z * (Y + N - T) = N * X
            // ZY + ZN - ZT = NX
            // ZY - ZT = N(X - Z)
            // N = (ZY - ZT) / (X - Z)
            // N = Z(Y - T) / (X - Z)
            // subtract delegatee balance from N since it was already transferred to the delegator
            _mint(
                delegator,
                Math.mulDiv(
                    assets,
                    totalSupply - delegateeBalance,
                    uint256(Math.max(1, int256(totalAssets()) - int256(assets)))
                ) - delegateeBalance
            );
        }
        // if requested amount < delegatee balance, then just transfer shares back
        else {
            _transferFrom(delegatee, delegator, shares);
        }
    }

    /// @notice Refunds delegated tokens to 'refunder' from 'refundee', similar to 'revoke'
    /// @dev Assumes that the refunder has enough money to pay for the refund
    /// @dev can handle negative refund amounts that go from refundee to refunder in the case of high exercise fees.
    /// @param refunder The account refunding tokens to 'refundee'.
    /// @param refundee The account being refunded to.
    /// @param assets The amount of assets to refund. Positive means a transfer from refunder to refundee, vice versa for negative.
    function refund(address refunder, address refundee, int256 assets) external onlyPanopticPool {
        if (assets > 0) {
            _transferFrom(refunder, refundee, convertToShares(uint256(assets)));
        } else {
            unchecked {
                _transferFrom(refundee, refunder, convertToShares(uint256(-assets)));
            }
        }
    }

    /*//////////////////////////////////////////////////////////////
                     OPTION EXERCISE AND COMMISSION
    //////////////////////////////////////////////////////////////*/

    /// @notice Take commission on option creation/opening (commissions will not be taken on closing).
    /// @param optionOwner The user minting the option.
    /// @param longAmount The amount of longs.
    /// @param shortAmount The amount of shorts.
    /// @param swappedAmount The amount of tokens swapped during creation of the option position (non-zero for options minted ITM).
    /// @return utilization The utilization of the Panoptic Pool.
    function takeCommissionAddData(
        address optionOwner,
        int128 longAmount,
        int128 shortAmount,
        int128 swappedAmount
    ) external onlyPanopticPool returns (int256 utilization) {
        unchecked {
            // current available assets belonging to PLPs (updated after settlement) excluding any premium paid
            int256 updatedAssets = int256(uint256(s_poolAssets)) - swappedAmount;

            // constrict premium to only assets not belonging to PLPs (i.e premium paid by sellers or collected from the pool earlier)
            int256 tokenToPay = _getExchangedAmount(longAmount, shortAmount, swappedAmount);

            // compute tokens to be paid due to swap
            // mint or burn tokens due to minting in-the-money
            if (tokenToPay > 0) {
                // if user must pay tokens, burn them from user balance
                uint256 sharesToBurn = Math.mulDivRoundingUp(
                    uint256(tokenToPay),
                    totalSupply,
                    totalAssets()
                );
                _burn(optionOwner, sharesToBurn);
            } else if (tokenToPay < 0) {
                // if user must receive tokens, mint them
                uint256 sharesToMint = convertToShares(uint256(-tokenToPay));
                _mint(optionOwner, sharesToMint);
            }

            // update stored asset balances with net moved amounts
            // the inflow or outflow of pool assets is defined by the swappedAmount: it includes both the ITM swap amounts and the short/long amounts used to create the position
            // however, any intrinsic value is paid for by the users, so we only add the portion that comes from PLPs: the short/long amounts
            // premia is not included in the balance since it is the property of options buyers and sellers, not PLPs
            s_poolAssets = uint128(uint256(updatedAssets));
            s_inAMM = uint128(uint256(int256(uint256(s_inAMM)) + (shortAmount - longAmount)));

            utilization = _poolUtilization();
        }
    }

    /// @notice Exercise an option and pay to the seller what is owed from the buyer.
    /// @dev Called when a position is burnt because it may need to be exercised.
    /// @param optionOwner The owner of the option being burned and potentially exercised.
    /// @param longAmount The amount of longs to be exercised (if any).
    /// @param shortAmount The amount of shorts to be exercised (if any).
    /// @param swappedAmount The amount of tokens potentially swapped.
    /// @param realizedPremium Premium to settle on the current positions.
    /// @return paidAmount The amount of tokens paid when closing that position.
    function exercise(
        address optionOwner,
        int128 longAmount,
        int128 shortAmount,
        int128 swappedAmount,
        int128 realizedPremium
    ) external onlyPanopticPool returns (int128) {
        unchecked {
            // current available assets belonging to PLPs (updated after settlement) excluding any premium paid
            int256 updatedAssets = int256(uint256(s_poolAssets)) - swappedAmount;

            // add premium to be paid/collected on position close
            int256 tokenToPay = -realizedPremium;

            // if burning ITM and swap occurred, compute tokens to be paid through exercise and add swap fees
            int256 intrinsicValue = swappedAmount - (longAmount - shortAmount);

            if ((intrinsicValue != 0) && ((shortAmount != 0) || (longAmount != 0))) {
                // intrinsic value is the amount that need to be exchanged due to burning in-the-money

                // add the intrinsic value to the tokenToPay
                tokenToPay += intrinsicValue;
            }

            if (tokenToPay > 0) {
                // if user must pay tokens, burn them from user balance (revert if balance too small)
                uint256 sharesToBurn = Math.mulDivRoundingUp(
                    uint256(tokenToPay),
                    totalSupply,
                    totalAssets()
                );
                _burn(optionOwner, sharesToBurn);
            } else if (tokenToPay < 0) {
                // if user must receive tokens, mint them
                uint256 sharesToMint = convertToShares(uint256(-tokenToPay));
                _mint(optionOwner, sharesToMint);
            }

            // update stored asset balances with net moved amounts
            // any intrinsic value is paid for by the users, so we do not add it to s_inAMM
            // premia is not included in the balance since it is the property of options buyers and sellers, not PLPs
            s_poolAssets = uint128(uint256(updatedAssets + realizedPremium));
            s_inAMM = uint128(uint256(int256(uint256(s_inAMM)) - (shortAmount - longAmount)));

            return (int128(tokenToPay));
        }
    }

    /// @notice Get the amount exchanged to mint an option.
    /// @param longAmount The amount of long options held.
    /// @param shortAmount The amount of short options held.
    /// @param swappedAmount The (potential) amount swapped during any ITM option creations.
    /// @return exchangedAmount The amount of funds to be exchanged for minting an option (includes commission, swapFee, and intrinsic value).
    function _getExchangedAmount(
        int128 longAmount,
        int128 shortAmount,
        int128 swappedAmount
    ) internal view returns (int256 exchangedAmount) {
        // If amount swapped is positive, the amount of tokens to pay is the ITM amount

        unchecked {
            // intrinsic value is the amount that need to be exchanged due to minting in-the-money
            int256 intrinsicValue = swappedAmount - (shortAmount - longAmount);

            if (intrinsicValue != 0) {
                // the swap commission is paid on the intrinsic value, and it is always positive
                uint256 swapCommission = Math.unsafeDivRoundingUp(
                    s_ITMSpreadFee * uint256(Math.abs(intrinsicValue)),
                    DECIMALS
                );

                // set the exchanged amount to the sum of the intrinsic value and swapCommission
                exchangedAmount = intrinsicValue + int256(swapCommission);
            }

            //compute total commission amount = commission rate + spread fee
            exchangedAmount += int256(
                Math.unsafeDivRoundingUp(
                    uint256(uint128(shortAmount + longAmount)) * COMMISSION_FEE,
                    DECIMALS
                )
            );
        }
    }

    /*//////////////////////////////////////////////////////////////
                     HEALTH AND COLLATERAL TRACKING
    //////////////////////////////////////////////////////////////*/

    /// @notice Get the collateral status/margin details of an account/user.
    /// NOTE: It's up to the caller to confirm from the returned result that the account has enough collateral.
    /// @dev This can be used to check the health: how many tokens a user has compared to the margin threshold.
    /// @param user The account to check collateral/margin health for.
    /// @param currentTick The current AMM price tick.
    /// @param positionBalanceArray The list of all historical positions held by the 'optionOwner', stored as [[tokenId, balance/poolUtilizationAtMint], ...].
    /// @param premiumAllPositions The premium collected thus far across all positions.
    /// @return tokenData Information collected for the tokens about the health of the account.
    /// The collateral balance of the user is in the right slot and the threshold for margin call is in the left slot.
    function getAccountMarginDetails(
        address user,
        int24 currentTick,
        uint256[2][] memory positionBalanceArray,
        int128 premiumAllPositions
    ) public view returns (LeftRightUnsigned tokenData) {
        tokenData = _getAccountMargin(user, currentTick, positionBalanceArray, premiumAllPositions);
    }

    /// @notice Get the collateral status/margin details of an account/user.
    /// NOTE: It's up to the caller to confirm from the returned result that the account has enough collateral.
    /// @dev This can be used to check the health: how many tokens a user has compared to the margin threshold.
    /// @param user the account to check collateral/margin health for.
    /// @param atTick tick to convert values at. This can be the current tick or the Uniswap pool TWAP tick.
    /// @param positionBalanceArray the list of all historical positions held by the 'optionOwner', stored as [[tokenId, balance/poolUtilizationAtMint], ...].
    /// @param premiumAllPositions the premium collected thus far across all positions.
    /// @return tokenData information collected for the tokens about the health of the account.
    /// The collateral balance of the user is in the right slot and the threshold for margin call is in the left slot.
    function _getAccountMargin(
        address user,
        int24 atTick,
        uint256[2][] memory positionBalanceArray,
        int128 premiumAllPositions
    ) internal view returns (LeftRightUnsigned tokenData) {
        uint256 tokenRequired;

        // if the account has active options, compute the required collateral to keep account in good health
        if (positionBalanceArray.length > 0) {
            // get all collateral required for the incoming list of positions
            tokenRequired = _getTotalRequiredCollateral(atTick, positionBalanceArray);

            // If premium is negative (ie. user has to pay for their purchased options), add this long premium to the token requirement
            if (premiumAllPositions < 0) {
                unchecked {
                    tokenRequired += uint128(-premiumAllPositions);
                }
            }
        }

        // if premium is positive (ie. user will receive funds due to selling options), add this premum to the user's balance
        uint256 netBalance = convertToAssets(balanceOf[user]);
        if (premiumAllPositions > 0) {
            unchecked {
                netBalance += uint256(uint128(premiumAllPositions));
            }
        }

        // store assetBalance and tokens required in tokenData variable
        tokenData = tokenData.toRightSlot(netBalance.toUint128()).toLeftSlot(
            tokenRequired.toUint128()
        );
        return tokenData;
    }

    /// @notice Get the total required amount of collateral tokens of a user/account across all active positions to stay above the margin requirement.
    /// @dev Returns the token amounts required for the entire account with active positions in 'positionIdList' (list of tokenIds).
    /// @param atTick Tick to convert values at. This can be the current tick or the Uniswap pool TWAP tick.
    /// @param positionBalanceArray The list of all historical positions held by the 'optionOwner', stored as [[tokenId, balance/poolUtilizationAtMint], ...].
    /// @return tokenRequired The amount of tokens required to stay above the margin threshold for all active positions of user.
    function _getTotalRequiredCollateral(
        int24 atTick,
        uint256[2][] memory positionBalanceArray
    ) internal view returns (uint256 tokenRequired) {
        // loop through each active position.
        // Offset determined whether to consider the last tokenId from the list
        // (a potentially newly minted position)
        uint256 totalIterations = positionBalanceArray.length;
        for (uint256 i = 0; i < totalIterations; ) {
            // read the ith tokenId from the account
            TokenId tokenId = TokenId.wrap(positionBalanceArray[i][0]);

            // read the position size and the pool utilization at mint
            uint128 positionSize = LeftRightUnsigned.wrap(positionBalanceArray[i][1]).rightSlot();

            // read the pool utilization at mint
            uint128 poolUtilization = LeftRightUnsigned.wrap(positionBalanceArray[i][1]).leftSlot();

            // Get tokens required for the current tokenId (a single active position)
            uint256 _tokenRequired = _getRequiredCollateralAtTickSinglePosition(
                tokenId,
                positionSize,
                atTick,
                poolUtilization
            );

            // add to the tokenRequired accumulator
            unchecked {
                tokenRequired += _tokenRequired;
            }
            unchecked {
                ++i;
            }
        }

        return tokenRequired;
    }

    /// @notice Get the required amount of collateral tokens corresponding to a specific single position 'tokenId' at a price 'tick'.
    /// The required collateral of an account depends on the price ('tick') in the AMM pool: if in the position's favor less collateral needed, etc.
    /// @param tokenId The option position.
    /// @param positionSize The size of the option position.
    /// @param atTick Tick to convert values at. This can be the current tick or the Uniswap pool TWAP tick.
    /// @param poolUtilization The utilization of the Panoptic pool (balance of buying and selling).
    /// @return tokenRequired total required tokens for all legs of the specified tokenId.
    function _getRequiredCollateralAtTickSinglePosition(
        TokenId tokenId,
        uint128 positionSize,
        int24 atTick,
        uint128 poolUtilization
    ) internal view returns (uint256 tokenRequired) {
        bool underlyingIsToken0 = s_underlyingIsToken0;
        uint256 numLegs = tokenId.countLegs();

        unchecked {
            for (uint256 index = 0; index < numLegs; ++index) {
                // revert if the tokenType does not match the current collateral token
                if (tokenId.tokenType(index) != (underlyingIsToken0 ? 0 : 1)) continue;
                // Increment the tokenRequired accumulator
                tokenRequired += _getRequiredCollateralSingleLeg(
                    tokenId,
                    index,
                    positionSize,
                    atTick,
                    poolUtilization
                );
            }
        }
    }

    /// @notice Calculate the required amount of collateral for a single leg 'index' of position 'tokenId' when the leg does not have a risk partner.
    /// @dev Also called "undefined risk."
    /// @param tokenId The option position.
    /// @param index The leg index (associated with a liquidity chunk) to consider a partner for.
    /// @param positionSize The size of the position.
    /// @param atTick Tick to convert values at. This can be the current tick or the Uniswap pool TWAP tick.
    /// @param poolUtilization The pool utilization: how much funds are in the Panoptic pool versus the AMM pool.
    /// @return required The required amount collateral needed for this leg 'index'.
    function _getRequiredCollateralSingleLeg(
        TokenId tokenId,
        uint256 index,
        uint128 positionSize,
        int24 atTick,
        uint128 poolUtilization
    ) internal view returns (uint256 required) {
        return
            tokenId.riskPartner(index) == index // does this leg have a risk partner? Affects required collateral
                ? _getRequiredCollateralSingleLegNoPartner(
                    tokenId,
                    index,
                    positionSize,
                    atTick,
                    poolUtilization
                )
                : _getRequiredCollateralSingleLegPartner(
                    tokenId,
                    index,
                    positionSize,
                    atTick,
                    poolUtilization
                );
    }

    /// @notice Calculate the required amount of collateral for leg 'index' of position 'tokenId' when the leg does not have a risk partner.
    /// @dev Also called "defined risk."
    /// @param tokenId The option position.
    /// @param index The leg index (associated with a liquidity chunk) to consider a partner for.
    /// @param positionSize The size of the position.
    /// @param atTick Tick to convert values at. This can be the current tick or the Uniswap pool TWAP tick.
    /// @param poolUtilization The pool utilization: ratio of how much funds are in the Panoptic pool versus the AMM pool.
    /// @return required The required amount collateral needed for this leg 'index'.
    function _getRequiredCollateralSingleLegNoPartner(
        TokenId tokenId,
        uint256 index,
        uint128 positionSize,
        int24 atTick,
        uint128 poolUtilization
    ) internal view returns (uint256 required) {
        // extract the tokenType (token0 or token1)
        uint256 tokenType = tokenId.tokenType(index);

        // compute the total amount of funds moved for that position
        LeftRightUnsigned amountsMoved = PanopticMath.getAmountsMoved(tokenId, positionSize, index);

        // amount moved is right slot if tokenType=0, left slot otherwise
        uint128 amountMoved = tokenType == 0 ? amountsMoved.rightSlot() : amountsMoved.leftSlot();

        // match tokenType with the correct pool utilization
        int64 utilization = tokenType == 0
            ? int64(uint64(poolUtilization))
            : int64(uint64(poolUtilization >> 64));

        uint256 isLong = tokenId.isLong(index);

        // start with base requirement, which is based on isLong value
        required = _getRequiredCollateralAtUtilization(amountMoved, isLong, utilization);

        // if the position is long, required tokens does not depend on price
        unchecked {
            if (isLong == 0) {
                // if position is short, check whether the position is out-the-money

                (int24 tickLower, int24 tickUpper) = tokenId.asTicks(index);

                // compute the collateral requirement as a fixed amount that doesn't depend on price
                if (
                    ((atTick >= tickUpper) && (tokenType == 1)) || // strike OTM when price >= upperTick for tokenType=1
                    ((atTick < tickLower) && (tokenType == 0)) // strike OTM when price < lowerTick for tokenType=0
                ) {
                    // position is out-the-money, collateral requirement = SCR * amountMoved
                    required;
                } else {
                    int24 strike = tokenId.strike(index);
                    // if position is ITM or ATM, then the collateral requirement depends on price:

                    // compute the ratio of strike to price for calls (or price to strike for puts)
                    // (- and * 2 in tick space are / and ^ 2 in price space so sqrtRatioAtTick(2 *(a - b)) = a/b (*2^96)
                    // both of these ratios decrease as the position becomes deeper ITM, and it is possible
                    // for the ratio of the prices to go under the minimum price
                    // (which is the limit of what getSqrtRatioAtTick supports)
                    // so instead we cap it at the minimum price, which is acceptable because
                    // a higher ratio will result in an increased slope for the collateral requirement
                    uint160 ratio = tokenType == 1 // tokenType
                        ? Math.getSqrtRatioAtTick(
                            Math.max24(2 * (atTick - strike), Constants.MIN_V3POOL_TICK)
                        ) // puts ->  price/strike
                        : Math.getSqrtRatioAtTick(
                            Math.max24(2 * (strike - atTick), Constants.MIN_V3POOL_TICK)
                        ); // calls -> strike/price

                    // compute the collateral requirement depending on whether the position is ITM & out-of-range or ITM and in-range:

                    /// ITM and out-of-range
                    if (
                        ((atTick < tickLower) && (tokenType == 1)) || // strike ITM but out of range price < lowerTick for tokenType=1
                        ((atTick >= tickUpper) && (tokenType == 0)) // strike ITM but out of range when price >= upperTick for tokenType=0
                    ) {
                        /**
                                    Short put BPR = 100% - (price/strike) + SCR

                           BUYING
                           POWER
                           REQUIREMENT
                         
                                         ^               .         .
                                         |        <- ITM . <-ATM-> . OTM ->
                           100% + SCR% - |--__           .    .    .
                                  100% - | . .¯¯--__     .    .    .
                                         |    .     ¯¯--__    .    .
                                   SCR - |    .          .¯¯--__________
                                         |    .          .    .    .
                                         +----+----------+----+----+--->   current
                                         0   Liqui-     Pa  strike Pb       price
                                             dation
                                             price = SCR*strike                                         
                         */

                        uint256 c2 = Constants.FP96 - ratio;

                        // compute the tokens required
                        // position is in-the-money, collateral requirement = amountMoved*(1-ratio) + SCR*amountMoved
                        required += Math.mulDiv96RoundingUp(amountMoved, c2);
                    } else {
                        // position is in-range (ie. current tick is between upper+lower tick): we draw a line between the
                        // collateral requirement at the lowerTick and the one at the upperTick. We use that interpolation as
                        // the collateral requirement when in-range, which always over-estimates the amount of token required
                        // Specifically:
                        //  required = amountMoved * (scaleFactor - ratio) / (scaleFactor + 1) + sellCollateralRatio*amountMoved
                        uint160 scaleFactor = Math.getSqrtRatioAtTick(
                            (tickUpper - strike) + (strike - tickLower)
                        );
                        uint256 c3 = Math.mulDivRoundingUp(
                            amountMoved,
                            scaleFactor - ratio,
                            scaleFactor + Constants.FP96
                        );
                        // position is in-the-money, collateral requirement = amountMoved*(1-SRC)*(scaleFactor-ratio)/(scaleFactor+1) + SCR*amountMoved
                        required += c3;
                    }
                }
            }
        }
    }

    /// @notice Calculate the required amount of collateral for leg 'index' for position 'tokenId' accounting for its partner leg.
    /// @notice If the two token long-types are different (one is a long, the other a short, e.g.) but the tokenTypes are the same, this is a spread
    /// a spread is a defined risk position which has a max loss given by difference between the long and short strikes.
    /// @notice If the two token long-types are the same but the tokenTypes are different (one is a call, the other a put, e.g.), this is a strangle -
    /// a strangle benefits from enhanced capital efficiency because only one side can be ITM at a time.
    /// @dev if the position is a spread, then the collateral requirement consists of two components:
    ///   1) The difference in notional value at both strikes: abs(strikeLong - strikeShort) or abs(strikeShort - strikeLong)
    ///   2) A spread term which is relevant for legs that have different widths (calendar spreads)
    /// @dev If a position is a strangle, only one leg can be tested at a time which allows us to increase the capital efficiency.
    /// @param tokenId the option position
    /// @param index the leg index (associated with a liquidity chunk) to consider a partner for
    /// @param positionSize the size of the position
    /// @param atTick tick to convert values at. This can be the current tick or the Uniswap pool TWAP tick.
    /// @param poolUtilization the pool utilization: how much funds are in the Panoptic pool versus the AMM pool.
    /// @return required the required amount collateral needed for this leg 'index', accounting for what the leg's risk partner is.
    function _getRequiredCollateralSingleLegPartner(
        TokenId tokenId,
        uint256 index,
        uint128 positionSize,
        int24 atTick,
        uint128 poolUtilization
    ) internal view returns (uint256 required) {
        // extract partner index (associated with another liquidity chunk)
        uint256 partnerIndex = tokenId.riskPartner(index);

        uint256 isLong = tokenId.isLong(index);
        if (isLong != tokenId.isLong(partnerIndex)) {
            if (isLong == 1) {
                // compute the total amount of funds moved for that position
                required = _computeSpread(
                    tokenId,
                    positionSize,
                    index,
                    partnerIndex,
                    poolUtilization
                );
            }
        } else {
            required = _computeStrangle(tokenId, index, positionSize, atTick, poolUtilization);
        }
    }

    /// @notice Get the base collateral requirement for an 'amount' at the current Panoptic pool 'utilization' level.
    /// @notice For a given incoming 'amount' - which is the size of a user position (e.g. opening a position), what is the corresponding required collateral to have.
    /// @dev NOTE this does not depend on the price of the AMM pool. This only computes what is needed in response to the current utilization.
    /// @param amount The amount from which required collateral is computed.
    /// @param isLong Whether the position is long (=1) or short (=0).
    /// @param utilization The utilization of the Panoptic pool (balance between sellers and buyers).
    /// @return required The required collateral corresponding to the incoming 'amount'.
    function _getRequiredCollateralAtUtilization(
        uint128 amount,
        uint256 isLong,
        int256 utilization
    ) internal view returns (uint256 required) {
        // if position is short, use sell collateral ratio
        if (isLong == 0) {
            // compute the sell collateral ratio, which depends on the pool utilization
            uint256 sellCollateral = _sellCollateralRatio(utilization);

            // compute required as amount*collateralRatio
            // can use unsafe because denominator is always nonzero
            unchecked {
                required = Math.unsafeDivRoundingUp(amount * sellCollateral, DECIMALS);
            }
        } else if (isLong == 1) {
            // if options is long, use buy collateral ratio
            // compute the buy collateral ratio, which depends on the pool utilization
            uint256 buyCollateral = _buyCollateralRatio(uint256(utilization));

            // compute required as amount*collateralRatio
            // can use unsafe because denominator is always nonzero
            unchecked {
                required = Math.unsafeDivRoundingUp(amount * buyCollateral, DECIMALS);
            }
        }
    }

    /// @notice Calculate the required amount of collateral for the spread portion of the spread position.
    /// @dev long leg requirement + 100% collateralized risk
    /// @dev may be higher than the requirement of non risk-partnered legs if the spread is very wide (risky)
    /// @param tokenId the option position.
    /// @param positionSize the size of the position.
    /// @param index the leg index of the LONG leg in the spread position.
    /// @param partnerIndex the index of the partnered SHORT leg in the spread position.
    /// @param poolUtilization the pool utilization: how much funds are in the Panoptic pool versus the AMM pool.
    /// @return spreadRequirement the required amount of collateral needed for the spread portion.
    function _computeSpread(
        TokenId tokenId,
        uint128 positionSize,
        uint256 index,
        uint256 partnerIndex,
        uint128 poolUtilization
    ) internal view returns (uint256 spreadRequirement) {
        // compute the total amount of funds moved for the position's current leg
        LeftRightUnsigned amountsMoved = PanopticMath.getAmountsMoved(tokenId, positionSize, index);

        // compute the total amount of funds moved for the position's partner leg
        LeftRightUnsigned amountsMovedPartner = PanopticMath.getAmountsMoved(
            tokenId,
            positionSize,
            partnerIndex
        );

        // amount moved is right slot if tokenType=0, left slot otherwise
        uint128 movedRight = amountsMoved.rightSlot();
        uint128 movedLeft = amountsMoved.leftSlot();

        // amounts moved for partner
        uint128 movedPartnerRight = amountsMovedPartner.rightSlot();
        uint128 movedPartnerLeft = amountsMovedPartner.leftSlot();

        uint256 tokenType = tokenId.tokenType(index);

        // compute the max loss of the spread

        // if asset is NOT the same as the tokenType, the required amount is simply the difference in notional values
        // ie. asset = 1, tokenType = 0:
        if (tokenId.asset(index) != tokenType) {
            unchecked {
                // always take the absolute values of the difference of amounts moved
                if (tokenType == 0) {
                    spreadRequirement = movedRight < movedPartnerRight
                        ? movedPartnerRight - movedRight
                        : movedRight - movedPartnerRight;
                } else {
                    spreadRequirement = movedLeft < movedPartnerLeft
                        ? movedPartnerLeft - movedLeft
                        : movedLeft - movedPartnerLeft;
                }
            }
        } else {
            unchecked {
                uint256 notional;
                uint256 notionalP;
                uint128 contracts;
                if (tokenType == 1) {
                    notional = movedRight;
                    notionalP = movedPartnerRight;
                    contracts = movedLeft;
                } else {
                    notional = movedLeft;
                    notionalP = movedPartnerLeft;
                    contracts = movedRight;
                }
                // the required amount is the amount of contracts multiplied by (notional1 - notional2)/min(notional1, notional2)
                // can use unsafe because denominator is always nonzero
                spreadRequirement = (notional < notionalP)
                    ? Math.unsafeDivRoundingUp((notionalP - notional) * contracts, notional)
                    : Math.unsafeDivRoundingUp((notional - notionalP) * contracts, notionalP);
            }
        }

        // calculate the spread requirement as max(max_loss, long_leg_col_req)
        // narrower spreads will be very capital efficient (1/3 of non-partnered CR!), but
        // wider spreads (an uncommon position w/ high max loss) may not benefit from risk partnering
        spreadRequirement = Math.max(
            spreadRequirement,
            _getRequiredCollateralAtUtilization(
                tokenType == 0 ? movedRight : movedLeft,
                1,
                tokenType == 0
                    ? int64(uint64(poolUtilization))
                    : int64(uint64(poolUtilization >> 64))
            )
        );
    }

    /// @notice Calculate the required amount of collateral for a strangle leg.
    /// Strangle legs are evaluated at 2x capital efficiency at low pool utilizations.
    /// @dev A strangle can only have only one of its leg tested at the same time, so this reduces the total risk and collateral requirement.
    /// @param tokenId The option position.
    /// @param positionSize The size of the position.
    /// @param index The leg index (associated with a liquidity chunk) to consider a partner for.
    /// @param atTick Tick to convert values at. This can be the current tick or the Uniswap pool TWAP tick.
    /// @param poolUtilization The pool utilization: how much funds are in the Panoptic pool versus the AMM pool.
    /// @return strangleRequired The required amount of collateral needed for the strangle leg.
    function _computeStrangle(
        TokenId tokenId,
        uint256 index,
        uint128 positionSize,
        int24 atTick,
        uint128 poolUtilization
    ) internal view returns (uint256 strangleRequired) {
        // If both tokenTypes are the same, then this is a long or short strangle.
        // A strangle is an options strategy in which the investor holds a position
        // in both a call and a put option with different strike prices,
        // but with the same expiration date and underlying asset.

        /// collateral requirement is for short strangles depicted:
        /**
                    Put side of a short strangle, BPR = 100% - (100% - SCR/2)*(price/strike)
           BUYING
           POWER
           REQUIREMENT
                         ^                    .
                         |           <- ITM   .  OTM ->
                  100% - |--__                .
                         |    ¯¯--__          .
                         |          ¯¯--__    .
                 SCR/2 - |                ¯¯--______ <------ base collateral is half that of a single-leg
                         +--------------------+--->   current
                         0                  strike     price
         */
        unchecked {
            // A negative pool utilization is used to denote a position which is a strangle
            // at low pool utilization's strangle legs are evaluated at 2x capital efficiency

            uint64 poolUtilization0 = uint64(poolUtilization);
            uint64 poolUtilization1 = uint64(poolUtilization >> 64);

            // add 1 to handle poolUtilization = 0

            poolUtilization =
                uint128(uint64(-int64(poolUtilization0 == 0 ? 1 : poolUtilization0))) +
                (uint128(uint64(-int64(poolUtilization1 == 0 ? 1 : poolUtilization1))) << 64);

            return
                strangleRequired = _getRequiredCollateralSingleLegNoPartner(
                    tokenId,
                    index,
                    positionSize,
                    atTick,
                    poolUtilization
                );
        }
    }
}
